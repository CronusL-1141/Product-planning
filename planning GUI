<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>äº§å“è§„åˆ’é™æ€åŸå‹</title>
  <style>
    body { font-family: sans-serif; margin:0; }
    #header { position: relative; text-align: center; margin-top: 10px; }
    #logo { display:block; margin:0 auto; width:300px; }
    #mascot { position:absolute; right:10px; top:50%; transform:translateY(-50%); width:100px; }
    #page-title { text-align:center; margin-top:10px; }
    #content { max-width:1200px; margin:20px auto; padding:10px; }
    #particle-canvas { position:fixed; top:0; left:0; width:100%; height:100%; z-index:-1; pointer-events:none; }
    table { width: 100%; border-collapse: collapse; margin-top: 20px; }
    th, td {
      border: 1px solid #ccc;
      padding: 6px 10px;
      text-align: center;
      vertical-align: middle;
    }
    th { background-color: #f2f2f2; }
    input[type="number"], input[type="text"] { width: 80px; }
    .locked { background-color: #eee; }
    .editable {
      border: none;
      background-color: transparent;
      width: 100%;
      text-align: center;
    }
    .editable:focus {
      outline: 1px solid #aaa;
      background-color: #f9f9f9;
    }
    .lock-toggle { cursor: pointer; }
    button.add-btn { font-size: 12px; margin: 2px; }
    tfoot td { font-weight: bold; background-color: #f8f8f8; }
    #summary { text-align:center; }
    .summary-table {
      display: inline-block;
      vertical-align: top;
      margin: 40px 20px 0;
      width: 300px;
      border: 1px solid #aaa;
    }
    .summary-table th, .summary-table td {
      border: 1px solid #ccc;
      padding: 4px 8px;
    }
  </style>
</head>
<body>

<canvas id="particle-canvas"></canvas>
<div id="header">
  <img id="logo" src="LOGO.jpg" alt="LOGO">
  <video id="mascot" src="å…ƒå®.mp4" autoplay loop muted></video>
  <h2 id="page-title" contenteditable="true" onblur="updateTitle()">2025å¹´æœ«ç›®æ ‡ - äº§å“è§„åˆ’è¡¨</h2>
</div>
<div id="content">
<button onclick="addMain()">â• æ–°ä¸»åˆ†ç±»</button>
<button id="download-btn" style="float:right" onclick="downloadExcel()">ä¸‹è½½</button>
<button id="undo-btn" style="float:right" onclick="undoData()">å›é€€</button>
<button id="auto-fill-btn" style="float:right" onclick="autoFill()">è‡ªåŠ¨å¡«å……</button>
<table>
  <thead id="table-header"></thead>
  <tbody id="table-body"></tbody>
  <tfoot>
    <tr>
      <td colspan="4">åˆè®¡</td>
      <td id="total-weighted-rate">--</td>
      <td>
        <input id="total-scale" type="number" onblur="totalScaleTarget=this.value; saveData();" />
        <span id="total-scale-lock" class="lock-toggle" onclick="toggleTotalLock('scale')">ğŸ”“</span>
      </td>
      <td>100%</td>
      <td>
        <input id="total-count" type="number" onblur="totalCountTarget=this.value; saveData();" />
        <span id="total-count-lock" class="lock-toggle" onclick="toggleTotalLock('count')">ğŸ”“</span>
      </td>
      <td>--</td>
      <td></td>
    </tr>
  </tfoot>
</table>

<div id="summary"></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/xlsx@0.18.5/dist/xlsx.full.min.js"></script>
<script>
var pageTitle = "2025å¹´æœ«ç›®æ ‡ - äº§å“è§„åˆ’è¡¨";
var mainLabel = "ä¸»åˆ†ç±»";
var sub1Label = "å­ç±»ä¸€";
var sub2Label = "å­ç±»äºŒ";
var summaryLocks = {};
var summaryRatioTargets = {};
var totalScaleTarget = null;
var totalCountTarget = null;
var totalScaleLocked = false;
var totalCountLocked = false;
var data = loadData();

const defaultData = [
  {
    main: "ä¸ªé‡‘",
    subs: [
      {
        sub1: "çº¯å›ºæ”¶",
        sub2s: [
          { sub2: "å¼€æ”¾å¼", rate: "", scale: "", count: "", scaleLocked: false, countLocked: false },
          { sub2: "å°é—­å¼", rate: "", scale: "", count: "", scaleLocked: false, countLocked: false }
        ]
      }
    ]
  }
];

function createDataRow(sub2) {
  return { sub2, rate: "", scale: "", count: "", scaleLocked: false, countLocked: false };
}

function baseName(name) {
  return name.replace(/[ï¼ˆ(][^ï¼‰)]*[ï¼‰)]/g, "").trim();
}

function updateTitle() {
  pageTitle = document.getElementById("page-title").textContent.trim();
  saveData();
}

function updateHeader(th, labelVar) {
  window[labelVar] = th.textContent.trim();
  saveData();
  renderTable(); // å…³é”®ï¼å¤±ç„¦å®æ—¶åˆ·æ–°ç»Ÿè®¡è¡¨
}


function saveData(skipBackup) {
  const current = JSON.stringify({
    data,
    pageTitle,
    mainLabel,
    sub1Label,
    sub2Label,
    summaryLocks,
    summaryRatioTargets,
    totalScaleTarget,
    totalCountTarget,
    totalScaleLocked,
    totalCountLocked
  });
  if (!skipBackup) {
    const prev = localStorage.getItem("productPlanningData");
    if (prev !== null) localStorage.setItem("productPlanningPrev", prev);
  }
  localStorage.setItem("productPlanningData", current);
}

function loadData() {
  const saved = localStorage.getItem("productPlanningData");
  if (!saved) return JSON.parse(JSON.stringify(defaultData));
  try {
    const obj = JSON.parse(saved);
    pageTitle = obj.pageTitle || pageTitle;
    mainLabel = obj.mainLabel || mainLabel;
    sub1Label = obj.sub1Label || sub1Label;
    sub2Label = obj.sub2Label || sub2Label;
    summaryLocks = obj.summaryLocks || {};
    summaryRatioTargets = obj.summaryRatioTargets || {};
    totalScaleTarget = obj.totalScaleTarget != null ? obj.totalScaleTarget : null;
    totalCountTarget = obj.totalCountTarget != null ? obj.totalCountTarget : null;
    totalScaleLocked = obj.totalScaleLocked || false;
    totalCountLocked = obj.totalCountLocked || false;
    return obj.data || defaultData;
  } catch {
    return JSON.parse(JSON.stringify(defaultData));
  }
}

function renderHeader() {
  const thead = document.getElementById("table-header");
  thead.innerHTML = "";
  const tr = document.createElement("tr");
  [mainLabel, sub1Label, sub2Label].forEach((label, i) => {
    const th = document.createElement("th");
    th.contentEditable = true;
    th.textContent = label;
    th.onblur = () => {
      // å¤šåŠ ä¸€å±‚é˜²æŠ–
      const newLabel = th.textContent.trim();
      if (window[["mainLabel", "sub1Label", "sub2Label"][i]] !== newLabel) {
        window[["mainLabel", "sub1Label", "sub2Label"][i]] = newLabel;
        saveData();
        renderTable();
      }
    };
    tr.appendChild(th);
  });
  ["è´¹ç‡", "åŠ æƒè´¹ç‡", "è§„æ¨¡ï¼ˆäº¿å…ƒï¼‰", "å æ¯”", "åªæ•°", "å•åªè§„æ¨¡", "æ“ä½œ"].forEach(text => {
    const th = document.createElement("th");
    th.textContent = text;
    tr.appendChild(th);
  });
  thead.appendChild(tr);
}

function renderTable() {
  renderHeader();
  document.getElementById("page-title").textContent = pageTitle;
  const tbody = document.getElementById("table-body");
  tbody.innerHTML = "";

  let totalScale = 0,
      totalCount = 0,
      weightedSum = 0;
  let groupMain = {}, groupSub1 = {}, groupSub2 = {}, groupSub2Bracket = {};

  // first pass to gather totals
  data.forEach(m => {
    m.subs.forEach(s1 => {
      s1.sub2s.forEach(row => {
        const scale = parseFloat(row.scale) || 0;
        const count = parseFloat(row.count) || 0;
        const rate = parseFloat(row.rate) || 0;
        totalScale += scale;
        totalCount += count;
        weightedSum += scale * rate;
        const mainKey = baseName(m.main);
        const sub1Key = baseName(s1.sub1);
        const sub2Key = baseName(row.sub2);
        groupMain[mainKey] = (groupMain[mainKey] || 0) + scale;
        groupSub1[sub1Key] = (groupSub1[sub1Key] || 0) + scale;
        groupSub2[sub2Key] = (groupSub2[sub2Key] || 0) + scale;
        if (/[ï¼ˆ(].*[ï¼‰)]/.test(row.sub2)) {
          groupSub2Bracket[row.sub2] = (groupSub2Bracket[row.sub2] || 0) + scale;
        }
      });
    });
  });

  const weightedRateTotal = totalScale > 0 ? weightedSum / totalScale : 0;

  // build table rows
  data.forEach((m, mi) => {
    m.subs.forEach((s1, si) => {
      s1.sub2s.forEach((row, ri) => {
        const tr = document.createElement("tr");

        const rowspanMain = m.subs.reduce((sum, s) => sum + s.sub2s.length, 0);
        const rowspanSub1 = s1.sub2s.length;

        if (si === 0 && ri === 0) {
          tr.innerHTML += `<td rowspan="${rowspanMain}">
            <input class="editable" value="${m.main}" onblur="data[${mi}].main=this.value; saveData(); renderTable()">
            <br><button class='add-btn' onclick='addSub1(${mi})'>â• å­ç±»ä¸€</button></td>`;
        }

        if (ri === 0) {
          tr.innerHTML += `<td rowspan="${rowspanSub1}">
            <input class="editable" value="${s1.sub1}" onblur="data[${mi}].subs[${si}].sub1=this.value; saveData(); renderTable()">
            <br><button class='add-btn' onclick='addSub2(${mi},${si})'>â• å­ç±»äºŒ</button></td>`;
        }

        const scale = parseFloat(row.scale) || 0;
        const count = parseFloat(row.count) || 0;
        const rate = parseFloat(row.rate) || 0;
        const scaleRatio = totalScale > 0 && scale ? ((scale / totalScale) * 100).toFixed(1) + "%" : "--";
        const weightedRate = totalScale > 0 && rate ? ((scale / totalScale) * rate).toFixed(2) + "%" : "--";
        const avgScale = scale && count ? (scale / count).toFixed(2) : "--";

        const lockKey = `${mi}-${si}-${ri}`;
        tr.innerHTML += `
          <td><input class='editable' value='${row.sub2}' onblur='data[${mi}].subs[${si}].sub2s[${ri}].sub2=this.value; saveData(); renderTable()'></td>
          <td><input type='text' value='${row.rate}' onblur='data[${mi}].subs[${si}].sub2s[${ri}].rate=this.value; saveData()'></td>
          <td>${weightedRate}</td>
          <td>
            <input type='number' value='${row.scale}' ${row.scaleLocked ? "disabled class='locked'" : ""}
              onblur='updateScale(${mi},${si},${ri}, this.value)'>
            <span class='lock-toggle' onclick='data[${mi}].subs[${si}].sub2s[${ri}].scaleLocked = !data[${mi}].subs[${si}].sub2s[${ri}].scaleLocked; saveData(); renderTable()'>${row.scaleLocked ? "ğŸ”’" : "ğŸ”“"}</span>
          </td>
          <td>${scaleRatio}</td>
          <td>
            <input type='number' value='${row.count}' ${row.countLocked ? "disabled class='locked'" : ""}
              onblur='updateCount(${mi},${si},${ri}, this.value)'>
            <span class='lock-toggle' onclick='data[${mi}].subs[${si}].sub2s[${ri}].countLocked = !data[${mi}].subs[${si}].sub2s[${ri}].countLocked; saveData(); renderTable()'>${row.countLocked ? "ğŸ”’" : "ğŸ”“"}</span>
          </td>
          <td>${avgScale}</td>
          <td><button onclick='deleteRow(${mi},${si},${ri})'>ğŸ—‘ï¸</button></td>`;
        tbody.appendChild(tr);
      });
    });
  });

  const scaleInput = document.getElementById("total-scale");
  const countInput = document.getElementById("total-count");
  document.getElementById("total-weighted-rate").textContent = totalScale > 0 ? weightedRateTotal.toFixed(2) + "%" : "--";
  scaleInput.value = totalScaleTarget != null ? totalScaleTarget : totalScale.toFixed(2);
  countInput.value = totalCountTarget != null ? totalCountTarget : totalCount.toFixed(0);
  scaleInput.disabled = totalScaleLocked;
  countInput.disabled = totalCountLocked;
  document.getElementById("total-scale-lock").textContent = totalScaleLocked ? "ğŸ”’" : "ğŸ”“";
  document.getElementById("total-count-lock").textContent = totalCountLocked ? "ğŸ”’" : "ğŸ”“";

  const extraTable = Object.keys(groupSub2Bracket).length > 0 ? renderBracketSummary(groupSub2Bracket, totalScale) : "";
  document.getElementById("summary").innerHTML =
    renderSummary("main", groupMain, totalScale) +
    renderSummary("sub1", groupSub1, totalScale) +
    renderSummary("sub2", groupSub2, totalScale) +
    extraTable;
}

function renderSummary(type, group, total) {
  // è¿™é‡Œç›´æ¥ç”¨ mainLabel ç­‰å˜é‡ï¼Œä¸è¦ç¡¬ç¼–ç 
  const label = type === "main" ? mainLabel : type === "sub1" ? sub1Label : sub2Label;
  let html = `<table class='summary-table'>
  <thead><tr><th colspan='4'><b>æŒ‰${label}ç»Ÿè®¡</b></th></tr>
  <tr><th></th><th>è§„æ¨¡</th><th>å æ¯”</th><th></th></tr></thead><tbody>`;

  for (let key in group) {
    const val = group[key];
    const ratioVal = total > 0 ? (val / total) * 100 : 0;
    const lockKey = `${type}-${key}`;
    const ratioLocked = summaryLocks[lockKey + "-ratio"];
    const ratioTarget = summaryRatioTargets[lockKey];
    const displayRatio = ratioLocked && ratioTarget != null ? ratioTarget : ratioVal.toFixed(0);

    html += `<tr><td><b>${key}</b></td>
      <td>${val.toFixed(0)}</td>
      <td><input type="text" value="${displayRatio}%" ${ratioLocked ? "disabled class='locked'" : ""}
        onblur="summaryRatioTargets['${lockKey}']=parseFloat(this.value); saveData();"></td>
      <td><span class='lock-toggle' onclick="summaryLocks['${lockKey}-ratio'] = !summaryLocks['${lockKey}-ratio']; saveData(); renderTable();">${ratioLocked ? "ğŸ”’" : "ğŸ”“"}</span></td></tr>`;
  }

  html += `<tr><td><b>åˆè®¡</b></td><td colspan="3"><b>${total.toFixed(0)}ï¼ˆ100%ï¼‰</b></td></tr></tbody></table>`;
  return html;
}

function renderBracketSummary(group, total) {
  let html = `<table class='summary-table'>
  <thead><tr><th colspan='3'><b>æŒ‰${sub2Label}ï¼ˆæ‹¬å·ï¼‰ç»Ÿè®¡</b></th></tr>
  <tr><th></th><th>è§„æ¨¡</th><th>å æ¯”</th></tr></thead><tbody>`;

  for (let key in group) {
    const val = group[key];
    const ratioVal = total > 0 ? (val / total) * 100 : 0;
    html += `<tr><td><b>${key}</b></td><td>${val.toFixed(0)}</td><td>${ratioVal.toFixed(0)}%</td></tr>`;
  }
  html += `<tr><td><b>åˆè®¡</b></td><td colspan="2"><b>${total.toFixed(0)}ï¼ˆ100%ï¼‰</b></td></tr></tbody></table>`;
  return html;
}

function addMain() {
  data.push({ main: "æ–°ä¸»åˆ†ç±»", subs: [{ sub1: "æ–°å­ç±»ä¸€", sub2s: [createDataRow("å¼€æ”¾å¼")] }] });
  saveData();
  renderTable();
}
function addSub1(mi) {
  data[mi].subs.push({ sub1: "æ–°å­ç±»ä¸€", sub2s: [createDataRow("å¼€æ”¾å¼")] });
  saveData();
  renderTable();
}
function addSub2(mi, si) {
  data[mi].subs[si].sub2s.push(createDataRow("æ–°å­ç±»äºŒ"));
  saveData();
  renderTable();
}

function updateScale(mi, si, ri, val) {
  data[mi].subs[si].sub2s[ri].scale = val;
  saveData();
  if (totalScaleLocked || totalCountLocked) autoFill();
  else renderTable();
}

function updateCount(mi, si, ri, val) {
  data[mi].subs[si].sub2s[ri].count = val;
  saveData();
  if (totalScaleLocked || totalCountLocked) autoFill();
  else renderTable();
}
function deleteRow(mi, si, ri) {
  data[mi].subs[si].sub2s.splice(ri, 1);
  if (data[mi].subs[si].sub2s.length === 0) data[mi].subs.splice(si, 1);
  if (data[mi].subs.length === 0) data.splice(mi, 1);
  saveData();
  renderTable();
}

function toggleTotalLock(type) {
  if (type === 'scale') {
    totalScaleLocked = !totalScaleLocked;
  } else {
    totalCountLocked = !totalCountLocked;
  }
  saveData();
  renderTable();
}

function autoFill() {
  // gather totals and group info
  let totalScale = 0,
      totalCount = 0;
  const groups = {};

  data.forEach((m, mi) => {
    const mainKey = baseName(m.main);
    groups[mainKey] = groups[mainKey] || {rows: [], lockedScale: 0, currentScale:0};
    m.subs.forEach((s1, si) => {
      s1.sub2s.forEach((row, ri) => {
        const scale = parseFloat(row.scale) || 0;
        const count = parseFloat(row.count) || 0;
        totalScale += scale;
        totalCount += count;
        const info = {row, scale, count};
        groups[mainKey].rows.push(info);
        groups[mainKey].currentScale += scale;
        if (row.scaleLocked) groups[mainKey].lockedScale += scale;
      });
    });
  });

  const targetScale = parseFloat(document.getElementById('total-scale').value) || totalScale;
  const targetCount = parseFloat(document.getElementById('total-count').value) || totalCount;

  // adjust scales within each main group according to locked ratios
  for (const key in groups) {
    const g = groups[key];
    const lockKey = `main-${key}`;
    const ratioLocked = summaryLocks[lockKey + '-ratio'];
    const ratioTarget = ratioLocked ? parseFloat(summaryRatioTargets[lockKey]) || 0 : (g.currentScale/totalScale*100);
    const targetGroupScale = targetScale * ratioTarget / 100;

    let unlocked = g.rows.filter(r => !r.row.scaleLocked);
    const withVal = unlocked.filter(r => r.row.scale);
    const empty = unlocked.filter(r => !r.row.scale);
    let remain = Math.max(targetGroupScale - g.lockedScale, 0);
    const sumWith = withVal.reduce((s, r) => s + (parseFloat(r.row.scale) || 0), 0);
    const factor = sumWith > 0 ? remain / sumWith : 0;
    withVal.forEach(r => { r.row.scale = +(parseFloat(r.row.scale) * factor).toFixed(2); remain -= parseFloat(r.row.scale); });
    if (empty.length > 0) {
      const per = remain / empty.length;
      empty.forEach(r => { r.row.scale = +per.toFixed(2); });
    }
  }

  // recompute totals after scale adjustments for count distribution
  totalScale = 0;
  totalCount = 0;
  let lockedCount = 0;
  const countWithVal = [];
  const countEmpty = [];
  data.forEach(m => {
    m.subs.forEach(s1 => {
      s1.sub2s.forEach(row => {
        const sc = parseFloat(row.scale) || 0;
        const ct = parseFloat(row.count) || 0;
        totalScale += sc;
        totalCount += ct;
        if (row.countLocked) {
          lockedCount += ct;
        } else {
          if (ct) countWithVal.push(row); else countEmpty.push(row);
        }
      });
    });
  });

  const targetCountAvail = targetCount - lockedCount;
  const sumCountWithVal = countWithVal.reduce((s, r) => s + (parseFloat(r.count) || 0), 0);
  const countFactor = sumCountWithVal > 0 ? targetCountAvail / sumCountWithVal : 0;
  countWithVal.forEach(r => { r.count = Math.round((parseFloat(r.count) || 0) * countFactor); });
  if (countEmpty.length > 0) {
    const per = Math.max(targetCountAvail - sumCountWithVal * countFactor, 0) / countEmpty.length;
    countEmpty.forEach(r => { r.count = Math.round(per); });
  }

  saveData();
  renderTable();
}

function undoData() {
  const prev = localStorage.getItem('productPlanningPrev');
  if (!prev) {
    alert('æ²¡æœ‰å¯å›é€€çš„æ•°æ®');
    return;
  }
  const obj = JSON.parse(prev);
  data = obj.data || [];
  pageTitle = obj.pageTitle || pageTitle;
  mainLabel = obj.mainLabel || mainLabel;
  sub1Label = obj.sub1Label || sub1Label;
  sub2Label = obj.sub2Label || sub2Label;
  summaryLocks = obj.summaryLocks || {};
  summaryRatioTargets = obj.summaryRatioTargets || {};
  totalScaleTarget = obj.totalScaleTarget;
  totalCountTarget = obj.totalCountTarget;
  totalScaleLocked = obj.totalScaleLocked || false;
  totalCountLocked = obj.totalCountLocked || false;
  saveData(true);
  renderTable();
}

function downloadExcel() {
  if (typeof XLSX === 'undefined') {
    alert('æ— æ³•åŠ è½½å¯¼å‡ºåº“');
    return;
  }
  const table = document.querySelector('table');
  const wb = XLSX.utils.table_to_book(table, {sheet: 'Sheet1'});
  XLSX.writeFile(wb, 'planning.xlsx');
}

function initParticles() {
  const canvas = document.getElementById('particle-canvas');
  const ctx = canvas.getContext('2d');
  const colors = ['red','yellow','green','blue','purple'];
  let particles = [];
  let mouse = {x:-1000,y:-1000};
  let blocks = [];

  function resize(){
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    blocks = Array.from(document.querySelectorAll('#header,#content')).map(el=>el.getBoundingClientRect());
  }
  window.addEventListener('resize', resize);
  resize();

  const baseR = 3;
  function outsideBlocks(x,y){
    return !blocks.some(r=>x>r.left&&x<r.right&&y>r.top&&y<r.bottom);
  }

  function createParticle(x=Math.random()*canvas.width, y=Math.random()*canvas.height){
    let px=x,py=y;
    for(let i=0;i<10 && !outsideBlocks(px,py);i++){
      px=Math.random()*canvas.width;
      py=Math.random()*canvas.height;
    }
    return {
      x:px,
      y:py,
      vx:(Math.random()-0.5)*2,
      vy:(Math.random()-0.5)*2,
      r: baseR*0.5 + Math.random()*baseR*1.5,
      color: colors[Math.floor(Math.random()*colors.length)]
    };
  }

  for(let i=0;i<50;i++) particles.push(createParticle());

  document.addEventListener('mousemove',e=>{mouse.x=e.clientX;mouse.y=e.clientY;});
  document.addEventListener('click',e=>{
    for(let i=0;i<5;i++) particles.push(createParticle(e.clientX,e.clientY));
  });

  function step(){
    ctx.clearRect(0,0,canvas.width,canvas.height);
    particles.forEach(p=>{
      p.x+=p.vx; p.y+=p.vy;
      if(p.x<0||p.x>canvas.width) p.vx*=-1;
      if(p.y<0||p.y>canvas.height) p.vy*=-1;
      if(outsideBlocks(p.x,p.y)){
        ctx.fillStyle=p.color;
        ctx.beginPath();
        ctx.arc(p.x,p.y,p.r,0,Math.PI*2);
        ctx.fill();
      }
    });
    particles.forEach(p=>{
      const dist=Math.hypot(p.x-mouse.x,p.y-mouse.y);
      if(dist<100 && outsideBlocks(p.x,p.y) && outsideBlocks(mouse.x,mouse.y)){
        ctx.strokeStyle=`rgba(0,0,0,${Math.max(0,(100-dist)/100)})`;
        ctx.lineWidth=1;
        ctx.beginPath();
        ctx.moveTo(p.x,p.y);
        ctx.lineTo(mouse.x,mouse.y);
        ctx.stroke();
      }
    });
    requestAnimationFrame(step);
  }
  step();
}

window.addEventListener("DOMContentLoaded", function(){
  initParticles();
  renderTable();
});
</script>

</body>
</html>
